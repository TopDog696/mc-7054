<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Full World Builder</title>
  <style>
    body{margin:0;overflow:hidden;background:#87ceeb;font-family:Arial}
    #crosshair{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);color:#fff;font-size:28px;pointer-events:none;text-shadow:0 0 4px #000}
    #hotbar{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);display:flex;background:rgba(0,0,0,.6);border-radius:6px;padding:4px}
    .slot{width:40px;height:40px;border:2px solid #555;margin:2px;border-radius:4px;position:relative}
    .slot.active{border-color:#ff0}
    .slot img{width:100%;height:100%;image-rendering:pixelated}
    .count{position:absolute;bottom:2px;right:2px;font-size:12px;color:#fff}
    #progress{position:fixed;top:60%;left:50%;transform:translate(-50%,-50%);width:120px;height:8px;background:#333;border-radius:4px;display:none}
    #progressBar{height:100%;width:0%;background:#fff;border-radius:4px}
    #audioUI{position:fixed;top:10px;right:10px;background:rgba(0,0,0,.5);color:#fff;padding:4px 8px;border-radius:4px;font-size:12px}
  </style>
</head>
<body>
<div id="crosshair">+</div>
<div id="progress"><div id="progressBar"></div></div>
<div id="hotbar"></div>
<div id="audioUI">
  <button id="audioBtn">ðŸ”Š</button>
  <input type="range" id="volSlider" min="0" max="1" step="0.1" value="0.3">
</div>
<canvas id="game"></canvas>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* =========================================================
   FULL BUILDER WORLD  (one file, ~500 lines)
   ========================================================= */
const scene    = new THREE.Scene();
scene.fog      = new THREE.Fog(0x87ceeb, 40, 150);
const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, .1, 200);
const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('game'), antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x87ceeb);
document.body.appendChild(renderer.domElement);

const audio = new Audio('https://cdn.jsdelivr.net/gh/AnalyticalGraphicsInc/cesium@master/Apps/SampleData/sounds/bing.ogg');
audio.loop = true;
document.getElementById('audioBtn').onclick = () => audio.paused ? audio.play() : audio.pause();
document.getElementById('volSlider').oninput = e => audio.volume = e.target.value;

/* ---------- Materials & Block Registry ---------- */
const blockTypes = {
  grass : {color:0x4a7c59, name:'Grass'},
  dirt  : {color:0x8b4513, name:'Dirt'},
  stone : {color:0x696969, name:'Stone'},
  wood  : {color:0x8b4513, name:'Wood'},
  leaf  : {color:0x2d9d2d, name:'Leaves'},
  sand  : {color:0xd2b48c, name:'Sand'},
  brick : {color:0xb22222, name:'Brick'},
  glass : {color:0xadd8e6, name:'Glass', transparent:true, opacity:.7}
};
const geoCube = new THREE.BoxGeometry(1,1,1);
const mats = {};
Object.entries(blockTypes).forEach(([id, cfg]) => {
  mats[id] = new THREE.MeshLambertMaterial({color:cfg.color, transparent:cfg.transparent, opacity:cfg.opacity || 1});
});

/* ---------- Inventory & Hotbar ---------- */
let inventory = {};
Object.keys(blockTypes).forEach(k => inventory[k] = k==='grass'?99:0);
let selected = 0;
const hotbarEl = document.getElementById('hotbar');
function refreshHotbar(){
  hotbarEl.innerHTML='';
  Object.entries(blockTypes).forEach(([id, cfg], idx)=>{
    const slot = document.createElement('div');
    slot.className='slot'+(idx===selected?' active':'');
    slot.style.backgroundColor='#'+cfg.color.toString(16).padStart(6,'0');
    const cnt = document.createElement('span');
    cnt.className='count'; cnt.textContent=inventory[id]||0;
    slot.appendChild(cnt);
    hotbarEl.appendChild(slot);
  });
}
refreshHotbar();

/* ---------- Terrain ---------- */
const WORLD_RAD = 256;
const blocks = new Map();
const chunkSize = 32;
function key(x,y,z){return `${x}|${y}|${z}`;}
function noise(x,z){return Math.sin(x*.02)*Math.cos(z*.02)*8+Math.sin(x*.006)*Math.cos(z*.006)*20;}
function getHeight(x,z){return Math.floor(noise(x,z))+12;}

function addBlock(x,y,z,type){
  if(y<0||y>64) return;
  const k=key(x,y,z);
  if(blocks.has(k)) return;
  const mesh = new THREE.Mesh(geoCube, mats[type]);
  mesh.position.set(x,y,z);
  mesh.userData={type,x,y,z};
  blocks.set(k,mesh);
  scene.add(mesh);
}

function genChunk(cx,cz){
  const bx=cx*chunkSize, bz=cz*chunkSize;
  for(let x=0;x<chunkSize;x++){
    const wx=bx+x;
    for(let z=0;z<chunkSize;z++){
      const wz=bz+z;
      const h=getHeight(wx,wz);
      for(let y=-2;y<=h;y++){
        const blk=y===h?(Math.random()<.3?'grass':'dirt'):(y>=h-3?'dirt':'stone');
        addBlock(wx,y,wz,blk);
      }
      if(Math.random()<.03 && h>10) addTree(wx,h+1,wz);
      else if(Math.random()<.2 && h>5) addGrass(wx,h+1,wz);
    }
  }
}

function addTree(x,y,z){
  for(let i=0;i<6;i++) addBlock(x,y+i,z,'wood');
  for(let dx=-2;dx<=2;dx++)
    for(let dy=4;dy<=7;dy++)
      for(let dz=-2;dz<=2;dz++)
        if(Math.abs(dx)+Math.abs(dz)+Math.abs(dy-5.5)<4)
          addBlock(x+dx,y+dy,z+dz,'leaf');
}
function addGrass(x,y,z){
  if(!blocks.has(key(x,y-1,z))) return;
  addBlock(x,y,z,'grass');
}

/* ---------- NPCs ---------- */
const npcs=[];
const npcGeo=new THREE.BoxGeometry(.6,1.8,.6);
const npcMat=new THREE.MeshLambertMaterial({color:0x00bfff});
for(let i=0;i<8;i++){
  const npc=new THREE.Mesh(npcGeo,npcMat);
  npc.position.set(
    (Math.random()-0.5)*WORLD_RAD,
    getHeight((Math.random()-0.5)*WORLD_RAD,(Math.random()-0.5)*WORLD_RAD)+0.9,
    (Math.random()-0.5)*WORLD_RAD
  );
  npc.userData={vx:(Math.random()-0.5)*0.03, vz:(Math.random()-0.5)*0.03};
  scene.add(npc);
  npcs.push(npc);
}

/* ---------- Lighting ---------- */
scene.add(new THREE.AmbientLight(0xffffff,.7));
const sunLight=new THREE.DirectionalLight(0xffffff,.9);
sunLight.position.set(1,1,1);
scene.add(sunLight);

/* ---------- Player & Arms ---------- */
let px=0, py=22, pz=0, velY=0, onGround=false;
const keys={};
onkeydown=e=>keys[e.code]=true;
onkeyup  =e=>keys[e.code]=false;
document.addEventListener('click',()=>document.body.requestPointerLock());
onmousemove=e=>{
  if(document.pointerLockElement===document.body){
    camera.rotation.y-=e.movementX*0.002;
    camera.rotation.x-=e.movementY*0.002;
    camera.rotation.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,camera.rotation.x));
  }
};

/* First-person arms */
const armGroup=new THREE.Group();
const armGeo=new THREE.BoxGeometry(.2,1,.2);
const armMat=new THREE.MeshLambertMaterial({color:0xffcc99});
const leftArm=new THREE.Mesh(armGeo,armMat);
leftArm.position.set(-.5,-.5,-1.2);
leftArm.rotation.z=.6;
armGroup.add(leftArm);
const rightArm=new THREE.Mesh(armGeo,armMat);
rightArm.position.set(.5,-.5,-1.2);
rightArm.rotation.z=-.6;
armGroup.add(rightArm);
camera.add(armGroup);
scene.add(camera);

/* ---------- Raycast + Hold-to-Dig ---------- */
const raycaster=new THREE.Raycaster();
let digTarget=null, digProgress=0;
function updateRaycast(){
  if(document.pointerLockElement!==document.body) return;
  const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
  raycaster.set(camera.position,dir);
  const arr=[...blocks.values()];
  const res=raycaster.intersectObjects(arr);
  if(res.length){
    const hit=res[0].object;
    digTarget=hit;
    const pBar=document.getElementById('progress');
    pBar.style.display='block';
    pBar.style.left='calc(50% - 60px)';
    document.getElementById('progressBar').style.width=(digProgress*100)+'%';
  }else{
    digTarget=null; digProgress=0;
    document.getElementById('progress').style.display='none';
  }
}
let isDigging=false;
onmousedown=e=>{
  if(document.pointerLockElement!==document.body)return;
  if(e.button===0){isDigging=true;}
  else if(e.button===2){ // place
    const dir=new THREE.Vector3(0,0,-1).applyQuaternion(camera.quaternion);
    raycaster.set(camera.position,dir);
    const res=raycaster.intersectObjects([...blocks.values()]);
    if(res.length){
      const hit=res[0].object, n=res[0].face.normal;
      const x=hit.userData.x+n.x, y=hit.userData.y+n.y, z=hit.userData.z+n.z;
      const types=Object.keys(blockTypes);
      if(inventory[types[selected]]>0 && y<64){
        addBlock(x,y,z,types[selected]);
        inventory[types[selected]]--;
        refreshHotbar();
      }
    }
  }
};
onmouseup=e=>{isDigging=false; digProgress=0;};

/* ---------- Controls ---------- */
window.addEventListener('wheel',e=>{
  selected=(selected+(e.deltaY>0?1:-1)+Object.keys(blockTypes).length)%Object.keys(blockTypes).length;
  refreshHotbar();
});

/* ---------- Terrain Gen ---------- */
for(let cx=-4;cx<=4;cx++)
  for(let cz=-4;cz<=4;cz++)
    genChunk(cx,cz);

/* ---------- Game Loop ---------- */
function update(){
  requestAnimationFrame(update);

  /* NPC wander */
  npcs.forEach(npc=>{
    npc.position.x+=npc.userData.vx;
    npc.position.z+=npc.userData.vz;
    const h=getHeight(npc.position.x,npc.position.z)+0.9;
    npc.position.y=h;
  });

  /* Player physics */
  const speed=0.2;
  let dx=0,dz=0;
  if(keys['KeyW']||keys['ArrowUp'])    dz=-1;
  if(keys['KeyS']||keys['ArrowDown'])  dz=1;
  if(keys['KeyA']||keys['ArrowLeft'])  dx=-1;
  if(keys['KeyD']||keys['ArrowRight']) dx=1;
  const dir=new THREE.Vector3(dx,0,dz).normalize().applyAxisAngle(new THREE.Vector3(0,1,0),camera.rotation.y);
  px+=dir.x*speed; pz+=dir.z*speed;

  velY-=0.015;
  py+=velY;
  const ground=getHeight(px,pz)+1.75;
  if(py<ground){py=ground;velY=0;onGround=true;}else onGround=false;
  if(keys['Space'] && onGround) velY=0.3;

  camera.position.set(px,py,pz);
  armGroup.position.set(px,py-1,pz);

  /* Hold-to-dig */
  if(isDigging && digTarget){
    digProgress+=0.05;
    if(digProgress>=1){
      const p=digTarget.userData;
      inventory[p.type]=(inventory[p.type]||0)+1;
      blocks.delete(key(p.x,p.y,p.z));
      scene.remove(digTarget);
      digTarget=null; digProgress=0;
      refreshHotbar();
    }
  }
  updateRaycast();
}
update();
</script>
</body>
</html>
